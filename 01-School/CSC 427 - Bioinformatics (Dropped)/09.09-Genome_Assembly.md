### What we need to know about DNA
Double helix, has nucleotide "rungs" between them. Each nucleotide is half of a "rung" of DNA.
There's four types of nucleotide:
- A
- C
- G
- T
A always bonds to T
C always bonds to G
The if we lose one of the two strands of DNA, we can recover it using the other. 

Complexity of the organism does not correlate to the size of a genome. Humans have ~3 billion nucleotides, some type of amoeba has 670

Today, genome sequencing takes about 13 hours, costs about $400 to do.
### Sequencing overview
- Start with multiple identical copies of the genome we want to read
- Break the genomes into smaller "reads"
- Sequence each of the reads
- This results in an overlap puzzle, we want to assemble the complete genome from the individual reads

There's a number of complications
- DNA might be divided over 23-24 different chromosomes for humans
- Reads have imperfect coverage, there might be parts of the genomes that we didn't sequence
- Sequencing is error prone. Smaller reads give fewer errors, but then it's harder to assemble
- DNA is double stranded

**We'll make some assumptions for now**
- Genome has only a single chromosome
- We have perfect coverage
- Sequencing is error free
- DNA is single stranded

#### Formal definition of genome assembly
Input: collection of strings Reads
Output: a string Genome reconstructed from Reads

the k-mer composition of a string Text, denoted $\text{Composition}_k(\text{text})$, is the collection of all k-mer substrings of Text, if such a string exists.

A 3-mer means each read has length of 3

**Greedy algorithm**
for each k-mer, choose the k-mer of maximum overlap.
This is trivial to do, but not a good algorithm. Ends up being a brute force algorithm.
There's a large amount of prefix repetition, and a very large amount of large repeated sequences

**Better algorithm**
View the problem as a graph, where each k-mer is a vertex, and each suffix-prefix match has a directed edge. We want the Hamiltonian path, a path that goes through every vertex exactly once. This is NP-hard.

NP-hard is unacceptable. Luckily, we can do even better:

This time, the k-mers are *edges* instead of nodes. 
This is our starting point, with a "genome path"
![[Pasted image 20250910113512.png]]
We can label each node with just the two overlap characters:
![[Pasted image 20250910113609.png]]
Now we have repeated nodes. We merge them into each other:
![[Pasted image 20250910113652.png]]
Note that GG does loop into itself

This graph is called the **de Bruijn graph**, for k=3. As we increase the size of k, we get nicer and nicer looking graphs:
![[Pasted image 20250910113846.png]]
The genome path is called a *Eulerian path*, where it traverses every edge exactly once. This is a polynomial-time algorithm.

We can even do this if we don't have the initial full string. Each k-mer gives you the 2 nodes it's connected to, and we can stitch them together from there.

Some caveats for an Eulerian path:
- All nodes must have an even degree (number of edges) if we want it to be a cycle
- if we just want a path, 2 nodes must have an odd degree

Small change for a directed graphs:
- indegree: number of edges leading into a node
- outdegree: number of edges leading out of a node
- balanced graph: every node has an indegree equal to its outdegree
- strongly directed: any node is reachable from any other node

The algorithm connects cycles, we want a path. We solve this by adding an edge between two nodes with an odd degree, finding the cycle, then removing the extra edge.

___
Due to the real world, there's all sorts of problems with this.
We will not have a true, full, Eulerian path. Instead, we try to infer **contigs**: continuous genome sequences
![[Pasted image 20250910120936.png]]
Each contig is the maximal non-branching path, sort of like [basic blocks in code](07.08-Liveness_Analysis)

When there's sequence reads, we get what are called "bubbles":
![[Pasted image 20250910121209.png]]
But seeing a bubble does not always mean there's an error, that could also be a repeat, or just genetic variation.
If a very small number of reads give bubbles, it's probably an error. If it's closer to 50/50, it's more likely an actual variation

Yet another issue is that DNA is double-stranded, where each strand is a reverse complement of the other. We can't separate these in the read process, so both strands are combined in the de Bruijn graph