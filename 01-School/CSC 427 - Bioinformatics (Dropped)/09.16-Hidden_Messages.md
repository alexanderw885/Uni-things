### Finding the Replication Origin
Through a complicated biological process, DNA can replicate:
![[Pasted image 20250916113830.png]]
This replication begins in a region called the *replication origin.*, or ori How can we find it?

![[Pasted image 20250916114343.png]]

Before this, let's look at a seemingly different problem, finding the most frequent k-mer. This is a standard computer science problem, here's the result:
![[Pasted image 20250916114150.png]]
We can note that some of those 9-mers are inverse complements of each other.
These are likely DnaA boxes, as it's very unlikely for there to be so many repetitions of such long strings.

Unfortunately, these DnaA boxes are species dependant, we need to perform the same process for every different species

How might we find the ori in larger cases?
- Break the genome into ~500 nucleotide windows. These should be overlapping
- search each window to see how many frequent words the have
- ori candidates will have more frequent words, "clumps" of them.
The window size is an adjustable parameter, we can adjust it to see how results change

Let's better define clumps:
![[Pasted image 20250916115155.png]]
We want to find all k-mers that form (L,t)-clumps in the genome.
**This isn't that great a solution**. There can be so many repeats, this can give a uselessly large number of results we'd need to check. We need to narrow it down.

If we look at the difference of the frequency between G and C, we get this graph:
![[Pasted image 20250916115718.png]]
We find some section of the genome there the frequency flips. This section contains the ori.

Let's define skew:
- start with a value of 0
- traverse through the genome
- if you see a G, increment scew
- if you see C, decrement scew
We can graph this as you walk through the genome, and we'll get a graph that looks like this:
![[Pasted image 20250916120655.png]]
The point where skew starts increasing will be the ori.
If you see a bunch of values, this model is wrong for this genome.

___
### Finding Sequence Motifs
DNA is transcribed into RNA, which is then translated to proteins.

A transcription factor can increase or decrease the production of RNA and proteins.
These are activators to increase, and repressors to decrease or entirely stop it. These "switches" are k-mers, at some point before the gene
![[Pasted image 20250916121305.png]]
We know these keywords exist, and we might know roughly the size, but we don't know what they are. The motifs also won't be exactly the same for each gene.

Let Dna denote a collection of t strings, of length n.
If we choose a k-mer from each of the t strings, we have a collection of Motifs.
How can we know whether any one collection of Motifs is better then the others?

**What does better mean?**
We can make the *consensus string* by choosing the most frequent letter for each point in the motifs.
We can score each consensus be the number of strings that disagree with each consensus character:
![[Pasted image 20250916121802.png]]
A lower score is better than a higher score.

Now, we have an optimization problem. We want to find a set of motifs to lower this score. This is an optimization problem

We have $t$ strings Dna, and an integer $k$.
We want to find a collection of k-mers, one from each of the t strings, to minimize the score. We can't try all possibilities, as there's $(n-k+1)^t$ possibilities.

We do this using a gradient descent type of algorithm. This tends to just find local maximums, but it's computationally reasonable

**Algorithm**
Instead of a consensus, we create a profile matrix. For each column in our motifs, we store the probability of each character
![[Pasted image 20250917113714.png]]
With this, we can calculate the probability of any motif according to the matrix. The most likely k-mer string is the consensus.
One potential issue is that multiplying small numbers together can cause an underflow. Instead, the take the log of each probability value and add them together.
As the found motifs get closer and closer to the consensus, the probability of the consensus in.

in each Dna string, once the probability for each possible k-mer is calculated, change it's motif to the most likely possible string.


A variation of this, Gibbs sampling, only changes on random motif at each step instead of all of them. This can be even faster, but you need to be more careful since it could get stuck in a loop, or continue improving but at a negligible rate.
It also has much more randomness compared to the other algorithm, for better of worse.


We can combine both of these approaches to get around these problems. We use the Expectation Maximization algorithm.
Instead of calculating the probability of each k-mer from scratch in each iteration, we keep them all.
![[Pasted image 20250917120119.png]]
We don't need to sample Dna after the initial configuration, we just need to once, for the original profile.
- Use the profile to calculate the hidden matrix
- use the entire strings in Dna and the hidden matrix to calculate a new profile
- use the new profile to calculate a new matrix
Repeat until the profile is stable  

![[Pasted image 20250917120836.png]]

___

We can represent the probability of each character with a graph:
![[Pasted image 20250917120916.png]]