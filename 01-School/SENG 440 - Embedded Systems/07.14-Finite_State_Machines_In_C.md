Widely used in embedded systems for reactive systems.

Similar to FSMs in CSC classes, but actions can be performed in the transitions between states, and in the states themselves.

We might have a state machine with thousands of states. How can we implement this?

### Computation models
set of objects, rules for composing these objects, and execution semantics of composed objects.
the state machine model is used for control-dominant systems.
___
The system behaviour is described as a set of possible states, of which we can only be in one at a time.
states can transition to each other depending on some input, and code can be executed in this transition.

In this state, we only cover deterministic state machines, meaning each state has exactly one transition to every other state. transitions are exclusive and complete.

We absolutely can describe a finite state machine in a sequential language (like C, Java,...), the hard part is doing it efficiently. There's two main approaches
- use a template, and fill it in to create the state machine
- use a state machine oriented language, and then build a translator to a sequential language.

#### State charts
State charts are a graphical state machine oriented language, and part of UML. Along with basic state machines, it can encode hierarchy and concurrency.
![[Pasted image 20250717084638.png]]
#### SML
SML is an imperative programming language focused on state machines.
Timing is based on a clock signal. Computation is instantaneous, and changing a variable takes one cycle. Of course this isn't physically true. but that's how it's conceptualized.
It's very easy to describe concurrency with the `parallel` keyword:
```
parallel
  statement_1 ||
  statement_2 ||
  ...
  statement_n
```
#### the State Machine Compiler (SMC)
a java application, both a language and a compiler
### FSMs in C
we'll want some form of recursive organization, and we'll also need a structure to keep track of some information
- a state identifier
- an initialization function
- pointer to a structure that points to a next state or substate

We could use nested switch statements, but that leads to a lot of code.
We could use pointers to functions, but that might generate more overhead

#### Nested switch statements
fairly straight forwards. The outer switch statement is for the current state. It can have the code to perform in that state, and it contains another switch statement for the input signal.
```c
switch(state){
  case s_1:
    do_s1();
    switch(input){
      case i_1:
      ...
      case i_n:
      ...
    }
  case s_2:
  ...
}
```
it's simple, and it's good for small state machines, and has a small data memory footprint. However, it's not good for code reuse, and as the number of cases increases, event longer and longer to start.
They can also be very hard to fix or maintain, and they're prone to error.
Lastly, any type of nested state is very hard to show, as there's no hierarchy in the states.
#### Pointers to functions
to make a function pointer:
```c
int func(int i){
	...
}
int (*point) (int);

point = &func
```
now `point` is a pointer to the function `func`.

let's look at a small example:
```c
int Plus(int a, int b) { return a + b }
int Minus(int a, int b) { return a - b }

// Not using function pointer
int operate(int a, int b, char op){
  int result;
  switch(op){
    case '+': result = Plus(a,b); break;
    case '-': result = Minus(a,b); break;
  }
}

// Using a function pointer
int operate2(int a, int b, int* func){
	return func(a,b);
}

int main(){
  //calling first example
  operate(1,2,'+');
  
  //calling the second example
  operate2(1,2,&Plus);
}
```
There is a tiny bit of overhead due to pointer manipulation, but it's faster than the switch case.

How can we return function pointers from another function? One way is with `typedef`
![[Pasted image 20250717092526.png]]
now, `pt2Func` is a datatype for a function that takes in 2 floats, and returns a float.


for this method, we start with a state table
![[Pasted image 20250717090810.png]]
When we implement the table, each entry won't be a function, but the pointer to a function. Otherwise, the table would get very large. What would it look like to implement this?
![[Pasted image 20250717092722.png]]
![[Pasted image 20250717092734.png]]
This approach has some pros:
- promotes some code reuse
- constant dispatch time
- scales much better

But still has problems:
- requires the enumeration of states and signals
- requires a large state table
- better, but still not great at code reuse
- complex initialization
- non hierarchical

#### Object-Oriented approach
Can't be done in C, of course, but worth looking into. It's much easier to implement a hierarchy.
- each hierarchy gets a class
- each lower level in the hierarchy gets a subclass

