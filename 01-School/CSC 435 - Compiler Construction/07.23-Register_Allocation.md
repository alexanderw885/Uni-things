with IR generation, we assume an unlimited number of registers to make the conversion much easier. Unfortunately, physical hardware is much more limited. Converting IR temporaries into physical registers can be quite challenging.
On top of having a limited number of registers, different registers will have different purposes, potentially limiting the options further, and creating more interesting challenges in knowing what registers can be used when and where.

When mapping these temporaries to registers, there's often enough registers to fit everything. However, what do we do when there are more active variables then registers? This is register spilling, where we move variables into memory to make space for more immediately-used variables.

To allocate registers, we need to know when each temporary is [live](07.08-Liveness_Analysis). We'll need:
- Gen
- Kill
- IN
- OUT

#### Linear Scan
Using this liveness info, we can use the linear scan register allocation algorithm.
- track which registers are free at each point in time
- when a live interval begins, give the variable a free register
- when the live interval ends, the register is freed again
- Handle cases where we don't have enough registers available

At each program point, we find which algorithms are live. This step is the interval analysis. From there, it's fairly straight forwards to assign a register to each live variable as needed.

Linear scan is very efficient, especially after performing liveness analysis, and it often produces good enough code. It also works in just one pass. This is often the choice for JIT compilers.
However, live analysis can be a bit imprecise, and other techniques can often provide more efficient results.
##### Register spilling
There's only 4 registers, but 5 live variables. We need to "spill" one value in memory. How do we decide which value to spill? We spill the variable that won't be needed for the longest amount of time. Once we need that variable again, we fetch it again

#### Interference
another approach to help register sharing

The key is with a statement `x := y`. Even if x is not y, if they have the same value they can share a register. 
We make an undirected graph of variables:
- Vertices are variables
- edges represent specific interference relationships.

1. Start with all variables, and no edges
2. for each block:
	1. add an edge between all variables in IN
	2. add an edge between all variables used together in an instruction
From here, we can turn register allocation into a graph colouring problem.
This gives us good results, but it's an NP-hard problem.
#### Chaitin Algorithm
let's say we have k colours (k registers), and we want to colour a graph. Some nodes may have fewer than k edges, exactly k edges, or more than k edges.
1. Find a node with less than k edges
2. repeat until done: Remove this node and its edges, push it onto a stack. (this is `simplify`)
3. If we cannot find an edge with fewer than k edges, choose some node, push it to the stack *and mark it*.
4.  an empty graph, pop each node one by one, and try to colour it. (this is `select`)
5. If we cannot colour a node, mark that node as *spilled*.
This algorithm is very good for many CFGs, but the core approach is based on an NP-Hard algorithm, and it can produce a worst-case scenario.

Let's say we have a spilled value. We might be able to use linear scan, check when that spilled variable is live, and make a new graph separating each time a variable is live, and performing Chaitin again. 
While this can again give good results, just doing linear scan is much faster and often produces good enough results.